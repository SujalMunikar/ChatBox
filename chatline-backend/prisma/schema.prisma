// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/// Primary account record tracking credentials, profile, and friendship edges.
model User {
  id                    String          @id @default(uuid())
  email                 String          @db.VarChar(100)
  verified              Boolean         @default(false)
  name                  String          @db.VarChar(100)  
  password              String          @db.VarChar(255)
  image                 String?         @db.VarChar(255)
  otp                   String          @db.VarChar(10)   
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  sentMessages          Message[]       @relation("SentMessages")
  receivedMessages      Message[]       @relation("ReceivedMessages")
  conversations         Conversation[]  @relation("UserConversations")
  privateKey            String          @default("") @db.Text
  publicKey             String          @default("") @db.Text
  isOnline              Boolean         @default(false)
  lastSeen              DateTime?       @default(now())
  friends               Friendship[]    @relation("UserFriends")
  friendOf              Friendship[]    @relation("UserAsFriendOf")
  incomingFriendRequest FriendRequest[] @relation("UserFriendRequestTo")
  outgoingFriendRequest FriendRequest[] @relation("UserFriendRequestBy")
}

/// Chat payloads storing both plaintext and RSA-encrypted variants per participant.
model Message {
  id                          String        @id @default(uuid())
  sender                      User          @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  senderId                    String        @db.VarChar(36)
  receiver                    User          @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId                  String        @db.VarChar(36) 
  plainMessage                String?       @db.Text
  message                     String        @db.Text
  encryptedMessageFromSender  String        @db.Text
  encryptedMessageForReceiver String        @db.Text
  createdAt                   DateTime      @default(now())
  updatedAt                   DateTime      @updatedAt
  Conversation                Conversation? @relation("ConversationMessages", fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId              String?       @db.VarChar(36)
}

/// Conversation represents a unique pairing (or group) of users sharing messages.
model Conversation {
  id           String    @id @default(uuid())
  participants User[]    @relation("UserConversations")
  messages     Message[] @relation("ConversationMessages")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

/// Bidirectional friendship edges stored twiceâ€”once per user for simpler lookups.
model Friendship {
  id       String @id @default(uuid())
  user     User   @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  userId   String @db.VarChar(36) 
  friend   User   @relation("UserAsFriendOf", fields: [friendId], references: [id], onDelete: Cascade)
  friendId String @db.VarChar(36) 

  @@unique([userId, friendId])
}

/// Pending invitations between users before they become friendships.
model FriendRequest {
  id         String @id @default(uuid())
  sender     User   @relation("UserFriendRequestBy", fields: [senderId], references: [id])
  senderId   String @db.VarChar(36)
  receiver   User   @relation("UserFriendRequestTo", fields: [receiverId], references: [id])
  receiverId String @db.VarChar(36) 

  @@unique([senderId, receiverId])
}

/// Legacy status enum kept for forward compatibility with richer workflows.
enum RequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}